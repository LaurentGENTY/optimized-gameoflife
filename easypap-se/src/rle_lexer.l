
%{
#include <unistd.h>
#include <stdio.h>
#include <math.h>
#include <string.h>

#include "rle_lexer.h"
#include "img_data.h"
#include "debug.h"
#include "error.h"

static set_cell_func_t the_func = NULL;

static unsigned width = 0;
static unsigned height = 0;

static unsigned x = 0, xorig = 0, xdir = 0;
static unsigned y = 0, yorig = 0, ydir = 0;

static int dir = RLE_ORIENTATION_NORMAL;

static void treat_cell (char *s, int len, unsigned c)
{
  unsigned n = 1;
  if (len) {
    char number[16]; // 16 digits is probably enough to hold integers!
    strncpy (number, s, len);
    number[len] = '\0';
    n = atoi (number);
  }
    for (int i = 0; i < n; i++) {
      if (the_func && c)
        the_func (y, x);
      x += xdir;
      PRINT_DEBUG ('l', "%c", c ? '*' : ' ');
    }
}

static void carriage_return (char *s, int len)
{
  unsigned n = 1;
  if (len) {
    char number[16]; // 16 digits is probably enough to hold integers!
    strncpy (number, s, len);
    number[len] = '\0';
    n = atoi (number);
  }
  y += n * ydir;
  x = xorig;
  if (debug_flags != NULL && debug_enabled ('l')) { 
    for (int i = 0; i < n; i++)
      printf ("\n");
  }
}

static void set_initial_pos (void)
{
  xdir = ydir = 1;

  if (dir & RLE_ORIENTATION_HINVERT) {
    xorig = DIM - 1 - xorig;
    xdir = -1;
  }

  if (dir & RLE_ORIENTATION_VINVERT) {
    yorig = DIM - 1 - yorig;
    ydir = -1;
  }
  
  x = xorig;
  y = yorig;
}

static void complain (char *s)
{
  exit_with_error ("Lex parser encountered unexpected input \"%s\"\n", yytext);
}

%}

%option noyywrap

%x XINPUT
%x BETWEEN
%x YINPUT
%x AFTER
%x RLE

DIGIT    [0-9]
SEP      [ \t]

%%
#.*$                                  ;
\n                                    ;
{SEP}*x{SEP}*={SEP}*                  BEGIN(XINPUT);
<RLE>{DIGIT}*b                        treat_cell (yytext, yyleng - 1, 0);
<RLE>{DIGIT}*o                        treat_cell (yytext, yyleng - 1, 1);
<RLE>{DIGIT}*[$]                      carriage_return (yytext, yyleng -1);
<RLE>!                                carriage_return (NULL, 0); yyterminate();
<RLE>\n                               ;
<RLE>.                                complain (yytext);
<<EOF>>                               yyterminate();
<INITIAL>.                            complain (yytext);
<XINPUT>{DIGIT}+                      width = atoi(yytext); BEGIN(BETWEEN);
<XINPUT>.                             complain (yytext);
<BETWEEN>{SEP}*,{SEP}*y{SEP}*={SEP}*  BEGIN(YINPUT);
<YINPUT>{DIGIT}+                      height = atoi(yytext); set_initial_pos (); BEGIN(AFTER);
<YINPUT>.                             complain (yytext);
<AFTER>{SEP}*,{SEP}*rule{SEP}*=.*     ;
<AFTER>{SEP}*                         ;
<AFTER>\n                             BEGIN(RLE);
<AFTER>.                              complain (yytext);
%%

void rle_lexer_parse (char *filename, int xo, int yo, set_cell_func_t func, int orientation)
{
  the_func = func;
  xorig = xo;
  yorig = yo;
  dir = orientation;

  FILE *f = fopen (filename, "r");

  if (f == NULL)
    exit_with_error ("Cannot open file \"%s\": %s", filename, strerror (errno));
  
  yyrestart (f);
  BEGIN(INITIAL);
  
  yylex();

  fclose (f);
}

static void write_n_c (FILE *f, int n, char c, int *col)
{
  char buffer [16]; // should be enough to hold large numbers

  if (n == 1)
    sprintf (buffer, "%c", c);
  else
    sprintf (buffer, "%d%c", n, c);

  int len = strlen (buffer);
  if (*col + len > 70) {
    fputc ('\n', f);
    *col = 0;
  }
  fprintf (f, "%s", buffer);
  *col += len;
}

void rle_generate (int x, int y, int width, int height, get_cell_func_t func, char *filename)
{
  FILE *f = fopen (filename, "w");

  if (f == NULL)
    exit_with_error ("Cannot create file \"%s\": %s", filename, strerror (errno));

  fprintf (f, "#C RLE file generated by EasyPAP\n");
  fprintf (f, "x = %d, y = %d\n", width, height);

  int prev = -1;
  int count = 0;
  int linecount = 0;
  int col = 0;

  for (int i = y; i < y + height; i++) {
    for (int j = x; j < x + width; j++) {
      int current = func (i, j);
      if (current == prev) {
        count++;
      } else {
        if (current == 1 && linecount) {
          write_n_c (f, linecount, '$', &col);
          linecount = 0;
        }
        if (prev != -1)
          write_n_c (f, count, prev ? 'o' : 'b', &col);
        count = 1;
        prev = current;
      }
    }
    if (prev == 1)
      write_n_c (f, count, 'o', &col);
    prev = -1;
    count = 0;
    linecount++;
  }
  write_n_c (f, 1, '!', &col);

  fclose (f);
}